// ignore_for_file: lines_longer_than_80_chars

import 'dart:async';

import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:ht_categories_client/ht_categories_client.dart';

/// {@template ht_categories_firestore}
/// A Firestore implementation of the [HtCategoriesClient].
///
/// This class interacts with a Cloud Firestore database to manage [Category]
/// data. It handles fetching, creating, updating, and deleting categories.
///
/// It requires an instance of [FirebaseFirestore] to be provided during
/// instantiation, allowing for dependency injection and easier testing.
///
/// Errors during Firestore operations are caught and re-thrown as specific
/// exceptions defined in [HtCategoriesClient] (e.g., [GetCategoriesFailure],
/// [CategoryNotFoundFailure]).
/// {@endtemplate}
class HtCategoriesFirestore implements HtCategoriesClient {
  /// {@macro ht_categories_firestore}
  ///
  /// Requires a [FirebaseFirestore] instance.
  const HtCategoriesFirestore({
    required FirebaseFirestore firestore,
  }) : _firestore = firestore;

  final FirebaseFirestore _firestore;
  static const String _categoriesCollection = 'categories';

  /// Retrieves the Firestore collection reference for categories.
  CollectionReference<Map<String, dynamic>> get _collection =>
      _firestore.collection(_categoriesCollection);

  @override
  Future<Category> createCategory({
    required String name,
    String? description,
    String? iconUrl,
  }) async {
    final category = Category(
      name: name,
      description: description,
      iconUrl: iconUrl,
      // ID is generated by the Category constructor
    );
    final docRef = _collection.doc(category.id);

    try {
      await docRef.set(category.toJson());
      // Return the original category object as Firestore doesn't return
      // the created document directly on set.
      return category;
    } on FirebaseException catch (e, s) {
      throw CreateCategoryFailure(e, s);
    } catch (e, s) {
      // Catch any other potential errors
      throw CreateCategoryFailure(e, s);
    }
  }

  @override
  Future<void> deleteCategory(String id) async {
    final docRef = _collection.doc(id);

    try {
      // Get the document first to check existence, as delete() doesn't error
      // if the document is not found.
      final snapshot = await docRef.get();

      if (!snapshot.exists) {
        // Throw specific error if document doesn't exist before attempting delete
        throw CategoryNotFoundFailure(id, 'Document does not exist.');
      }

      // If it exists, proceed with deletion
      await docRef.delete();
    } on CategoryNotFoundFailure {
      // Re-throw if caught from the explicit check
      rethrow;
    } on FirebaseException catch (e, s) {
      // Handle potential Firestore errors during get() or delete()
      throw DeleteCategoryFailure(e, s);
    } catch (e, s) {
      // Catch any other potential errors during the process
      throw DeleteCategoryFailure(e, s);
    }
  }

  @override
  Future<List<Category>> getCategories({
    int? limit,
    String? startAfterId,
  }) async {
    try {
      // Start with the base query, ordered by name for consistent pagination
      Query<Map<String, dynamic>> query =
          _collection.orderBy('name', descending: false);

      // Handle pagination: fetch the document to start after
      if (startAfterId != null) {
        try {
          final startAfterSnapshot = await _collection.doc(startAfterId).get();
          if (startAfterSnapshot.exists) {
            query = query.startAfterDocument(startAfterSnapshot);
          }
          // If startAfterSnapshot doesn't exist, we don't add startAfterDocument.
          // The query proceeds from the beginning (respecting the order).
          // This handles cases where the startAfterId is invalid or deleted.
        } on FirebaseException catch (e, s) {
          // Treat failure to fetch the 'startAfter' doc as a general failure
          throw GetCategoriesFailure(
            'Failed to fetch document for pagination startAfterId: $startAfterId. Error: $e',
            s,
          );
        } catch (e, s) {
          throw GetCategoriesFailure(
            'An unexpected error occurred while fetching document for pagination startAfterId: $startAfterId. Error: $e',
            s,
          );
        }
      }

      // Apply limit if provided and valid
      if (limit != null && limit > 0) {
        query = query.limit(limit);
      }

      // Execute the final query
      final querySnapshot = await query.get();

      // Map documents to Category objects
      return querySnapshot.docs.map((doc) {
        final data = doc.data();
        // Ensure the document ID is included before parsing
        data['id'] = doc.id;
        return Category.fromJson(data);
      }).toList();
    } on FirebaseException catch (e, s) {
      // Catch Firestore errors during the main query execution
      throw GetCategoriesFailure(e, s);
    } catch (e, s) {
      // Catch any other potential errors during the process
      throw GetCategoriesFailure(e, s);
    }
  }

  @override
  Future<Category> getCategory(String id) async {
    final docRef = _collection.doc(id);

    try {
      final docSnapshot = await docRef.get();

      if (!docSnapshot.exists || docSnapshot.data() == null) {
        throw CategoryNotFoundFailure(id, 'Document does not exist.');
      }

      // Manually add the document ID to the data map before parsing
      final data = docSnapshot.data()!;
      data['id'] = docSnapshot.id;
      return Category.fromJson(data);
    } on FirebaseException catch (e, s) {
      // Specific check for Firestore not-found error, though the explicit
      // !docSnapshot.exists check is generally preferred and clearer.
      if (e.code == 'not-found') {
        throw CategoryNotFoundFailure(id, e, s);
      }
      throw GetCategoryFailure(e, s);
    } on CategoryNotFoundFailure {
      // Re-throw if caught from the explicit check
      rethrow;
    } catch (e, s) {
      // Catch any other potential errors
      throw GetCategoryFailure(e, s);
    }
  }

  @override
  Future<Category> updateCategory(Category category) async {
    final docRef = _collection.doc(category.id);

    try {
      // Directly attempt the update. Firestore's update throws if not found.
      await docRef.update(category.toJson());

      // Return the original category object passed in, as Firestore update
      // doesn't return the updated document directly.
      return category;
    } on FirebaseException catch (e, s) {
      // Check if the error is specifically 'not-found'
      if (e.code == 'not-found') {
        throw CategoryNotFoundFailure(category.id, e, s);
      }
      // Handle other potential Firestore errors during the update
      throw UpdateCategoryFailure(e, s);
    } on CategoryNotFoundFailure {
      // This catch block might seem redundant now, but kept for safety
      // in case CategoryNotFoundFailure is thrown by something else unexpected.
      rethrow;
    } catch (e, s) {
      // Catch any other potential errors during the process
      throw UpdateCategoryFailure(e, s);
    }
  }
}
